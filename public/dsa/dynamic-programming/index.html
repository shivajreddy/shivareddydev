<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Dynamic Programming | Shiva Reddy</title>
<meta name="keywords" content="">
<meta name="description" content="Summary for DP here">
<meta name="author" content="">
<link rel="canonical" href="https://shivareddy.dev/dsa/dynamic-programming/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.7e5f651b5a34db4e262a9162b9afabaa824ec72963a4d7a31706910bcc6b444d.css" integrity="sha256-fl9lG1o0204mKpFiua&#43;rqoJOxyljpNejFwaRC8xrRE0=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://shivareddy.dev/assets/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://shivareddy.dev/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://shivareddy.dev/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://shivareddy.dev/assets/favicon.ico">
<link rel="mask-icon" href="https://shivareddy.dev/assets/favicon.ico">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-5FGWR2YZ35"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-5FGWR2YZ35', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Dynamic Programming" />
<meta property="og:description" content="Summary for DP here" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://shivareddy.dev/dsa/dynamic-programming/" /><meta property="article:section" content="dsa" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Dynamic Programming"/>
<meta name="twitter:description" content="Summary for DP here"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Data Structures \u0026 Algorithms",
      "item": "https://shivareddy.dev/dsa/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Dynamic Programming",
      "item": "https://shivareddy.dev/dsa/dynamic-programming/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Dynamic Programming",
  "name": "Dynamic Programming",
  "description": "Summary for DP here",
  "keywords": [
    
  ],
  "articleBody": "Learning objectives:\nHow to solve optimization problems? YT Understand the difference b/w Greedy method and Dynamic programming.\nBoth are used for optimization problems. Optimization problems are those where you solve for minimum result or maximum result. Divide and conquer algorithms break the problem down into subproblems, but these subproblems are not overlapping. 1. Greedy Method: we follow a pre-defined procedure to get the optimal solution. And the procedure is optimal. Prim’s and Kruskal’s algorithm for finding Minimum Spanning Tree is a Greedy Method. In this method, we don’t explore all the variations, we find the most optimum solution. because when we start with a node, we look for another node that has the least edge weight with current node.\nSo here the act of choosing a node is optimal because we look for least weight, and we follow this procedure to get the final optimal solution. Decision is taken only once. and every stage follows this decision. Takes less space and time. 2. Dynamic Programming: we find all the possible results and then pick the optimal result.\nThough DP can be naturally represented as recursive formula’s we use iterative approach to solve DP problems. We can still use recursion, but mostly it’s iterative approach. DP follows principal of optimality: it means that a problem can be solved by taking a sequence of decisions to get the optimal solution. In DP every stage we take a decision. Takes more space and time. More time because we explore all possibilities. More space because in Top-Down approach we use memoization which stores all possible variations, hence more space. Types of DP problems: Bottom-up (Tabulation): Iterative approach - runtime is usually faster, as iteration does not have the overhead that recursion does. Top-Down (Memoization): Recursive approach - usually much easier to write. This is because with recursion, the ordering of subproblems does not matter, whereas with tabulation, we need to go through a logical ordering of solving subproblems. When to use DP The first characteristic that is common in DP problems is that the problem will ask for the optimum value (maximum or minimum) of something, or the number of ways there are to do something. For example:\nWhat is the minimum cost of doing… What is the maximum profit from… How many ways are there to do… What is the longest possible… Is it possible to reach a certain point… The second characteristic that is common in DP problems is that future “decisions” depend on earlier decisions. Deciding to do something at one step may affect the ability to do something in a later step. This characteristic is what makes a greedy algorithm invalid for a DP problem - we need to factor in results from previous decisions. Admittedly, this characteristic is not as well defined as the first one, and the best way to identify it is to go through some examples.\nHouse Robber is an excellent example of a dynamic programming problem. Longest Increasing Subsequence is another example of a classic dynamic programming problem. In this problem, we need to determine the length of the longest (first characteristic) subsequence that is strictly increasing. For example, if we had the input nums = [1, 2, 6, 3, 5]nums = [1, 2, 6, 3, 5], the answer would be 4, from the subsequence [1, 2, 3, 5][1, 2, 3, 5]. Again, the important decision comes when we arrive at the 6 - do we take it or not take it? If we decide to take it, then we get to increase our current length by 1, but it affects the future - we can no longer take the 3 or 5. Of course, with such a small example, it’s easy to see why we shouldn’t take it - but how are we supposed to design an algorithm that can always make the correct decision with huge inputs? Imagine if nums contained 10,00010,000 numbers instead.\nFramework for DP problems LeetCode - Link for this section\nBefore looking at the 3 things that make DP framework, understand what state \u0026 state variables are. State: a state is a set of variables that can sufficiently describe a scenario. These variables are called state variables, and we only care about relevant ones. tldr; all state variables together is the state.\nIn climbing stairs problem: To describe every scenario in Climbing Stairs, there is only 1 relevant state variable, the current step we are on. We can denote this with an integer ii. If i = 6i = 6, that means that we are describing the state of being on the 6th step. Every unique value of ii represents a unique state. In robbing houses problem: the amount of money in current house is a state variable. In coin change problem: the denomination is a state variable Mind map image: imagine that the framework is the tree/graph we are drawing, and now for the nodes we have to choose the state variables of the problem. because of the tree represents all the possible solutions for the problem, and the the state variables are those that we use to traverse in the tree to calculate the value for that path.\nFRAMEWORK:\nA function or data structure that will compute/contain the answer to the problem for every given state.\nData Structure is straightforward, say we have a dictionary for all the fibonacci numbers {num : fib(num) }\nFunction: instead of a Data Structure if we have a function that we can call and that returns the value for us. A recurrence relation to transition between states. Base cases, so that our recurrence relation doesn’t go on infinitely. Problem 1: MultiStage Graph YT Understanding the problem: It is a Directed weighted graph. All vertices are divided into stages. First and last stage will only have 1 node, start node and target node. Nodes connect only to the next stage. Goal is to find the least cost path from start to target. MultiStage Graph’s are used for solving resource allocation problems.\nFind the minimum cost of each vertex. when we start from 1, we have to already know the minimum cost path for 2,3,4,5 and these nodes depend on min. costs of nodes at V3 and so on. So we begin from last, (Bottom-Up approach, iteratively) because the node 12 is the end and the min. cost of 12 is 0. and from here we trace back. Now using forward approach.\n",
  "wordCount" : "1069",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://shivareddy.dev/dsa/dynamic-programming/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Shiva Reddy",
    "logo": {
      "@type": "ImageObject",
      "url": "https://shivareddy.dev/assets/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://shivareddy.dev/" accesskey="h" title="Shiva Reddy (Alt + H)">Shiva Reddy</a>
                    <div class="logo-switches">
                        <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                            <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                            </svg>
                            <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                                fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round">
                                <circle cx="12" cy="12" r="5"></circle>
                                <line x1="12" y1="1" x2="12" y2="3"></line>
                                <line x1="12" y1="21" x2="12" y2="23"></line>
                                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                                <line x1="1" y1="12" x2="3" y2="12"></line>
                                <line x1="21" y1="12" x2="23" y2="12"></line>
                                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                            </svg>
                        </button>
                    </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://shivareddy.dev/dsa" title="DSA">
                    <span>DSA</span>
                </a>
            </li>
        </ul>
    </nav>
</header><main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://shivareddy.dev/">Home</a>&nbsp;»&nbsp;<a href="https://shivareddy.dev/dsa/">Data Structures &amp; Algorithms</a></div>
    <h1 class="post-title">
      Dynamic Programming
    </h1>
    <div class="post-meta">

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#how-to-solve-optimization-problems-ythttpswwwyoutubecomwatchv5drgrueku3mlistpldn4rrl48xkpzkf03iyfl-o29szjtrs_oindex46" aria-label="How to solve optimization problems? YT">How to solve optimization problems? <a href="https://www.youtube.com/watch?v=5dRGRueKU3M&amp;list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O&amp;index=46">YT</a></a><ul>
                        
                <li>
                    <a href="#1-greedy-method" aria-label="1. Greedy Method:">1. Greedy Method:</a></li>
                <li>
                    <a href="#2-dynamic-programming" aria-label="2. Dynamic Programming:">2. Dynamic Programming:</a></li></ul>
                </li>
                <li>
                    <a href="#types-of-dp-problems" aria-label="Types of DP problems:">Types of DP problems:</a></li>
                <li>
                    <a href="#when-to-use-dp" aria-label="When to use DP">When to use DP</a></li>
                <li>
                    <a href="#framework-for-dp-problems" aria-label="Framework for DP problems">Framework for DP problems</a></li>
                <li>
                    <a href="#problem-1-multistage-graph-ythttpswwwyoutubecomwatchv9ie9mj4m8jklistpldn4rrl48xkpzkf03iyfl-o29szjtrs_oindex47" aria-label="Problem 1: MultiStage Graph YT">Problem 1: MultiStage Graph <a href="https://www.youtube.com/watch?v=9iE9Mj4m8jk&amp;list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O&amp;index=47">YT</a></a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>Learning objectives:</p>
<h3 id="how-to-solve-optimization-problems-ythttpswwwyoutubecomwatchv5drgrueku3mlistpldn4rrl48xkpzkf03iyfl-o29szjtrs_oindex46">How to solve optimization problems? <a href="https://www.youtube.com/watch?v=5dRGRueKU3M&amp;list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O&amp;index=46">YT</a><a hidden class="anchor" aria-hidden="true" href="#how-to-solve-optimization-problems-ythttpswwwyoutubecomwatchv5drgrueku3mlistpldn4rrl48xkpzkf03iyfl-o29szjtrs_oindex46">#</a></h3>
<p>Understand the difference b/w Greedy method and Dynamic programming.</p>
<ul>
<li>Both are used for <strong>optimization</strong> problems. Optimization problems are those where you solve for minimum result or maximum result.</li>
<li><strong>Divide and conquer algorithms break the problem down into subproblems, but these subproblems are not overlapping.</strong></li>
</ul>
<h4 id="1-greedy-method">1. Greedy Method:<a hidden class="anchor" aria-hidden="true" href="#1-greedy-method">#</a></h4>
<p>we follow a pre-defined procedure to get the optimal solution. And the procedure is optimal.
Prim&rsquo;s and Kruskal&rsquo;s algorithm for finding Minimum Spanning Tree is a Greedy Method. In this method, we don&rsquo;t explore all the variations, we find the most optimum solution. because when we start with a node, we look for another node that has the least edge weight with current node.</p>
<ul>
<li>So here the act of choosing a node is optimal because we look for least weight, and we follow this procedure to get the final optimal solution.</li>
<li>Decision is taken only once. and every stage follows this decision.</li>
<li>Takes less space and time.</li>
</ul>
<h4 id="2-dynamic-programming">2. Dynamic Programming:<a hidden class="anchor" aria-hidden="true" href="#2-dynamic-programming">#</a></h4>
<p>we find all the possible results and then pick the optimal result.</p>
<ul>
<li>Though DP can be naturally represented as recursive formula&rsquo;s we use iterative approach to solve DP problems. We can still use recursion, but mostly it&rsquo;s iterative approach.</li>
<li>DP follows <em><strong>principal of optimality</strong></em>: it means that a problem can be solved by taking a <strong>sequence of decisions</strong> to get the optimal solution.</li>
<li>In DP every stage we take a decision.</li>
<li>Takes more space and time. More time because we explore all possibilities. More space because in Top-Down approach we use memoization which stores all possible variations, hence more space.</li>
</ul>
<h3 id="types-of-dp-problems">Types of DP problems:<a hidden class="anchor" aria-hidden="true" href="#types-of-dp-problems">#</a></h3>
<ol>
<li>Bottom-up (Tabulation): Iterative approach - runtime is usually faster, as iteration does not have the overhead that recursion does.</li>
<li>Top-Down (Memoization): Recursive approach - usually much easier to write. This is because with recursion, the ordering of subproblems does not matter, whereas with tabulation, we need to go through a logical ordering of solving subproblems.</li>
</ol>
<h3 id="when-to-use-dp">When to use DP<a hidden class="anchor" aria-hidden="true" href="#when-to-use-dp">#</a></h3>
<p><strong>The first characteristic</strong> that is common in DP problems is that the problem will ask for the optimum value (maximum or minimum) of something, or the number of ways there are to do something. For example:</p>
<ul>
<li>What is the minimum cost of doing&hellip;</li>
<li>What is the maximum profit from&hellip;</li>
<li>How many ways are there to do&hellip;</li>
<li>What is the longest possible&hellip;</li>
<li>Is it possible to reach a certain point&hellip;</li>
</ul>
<p><strong>The second characteristic</strong> that is common in DP problems is that future &ldquo;decisions&rdquo; depend on earlier decisions. Deciding to do something at one step may affect the ability to do something in a later step. This characteristic is what makes a greedy algorithm invalid for a DP problem - we need to factor in results from previous decisions. Admittedly, this characteristic is not as well defined as the first one, and the best way to identify it is to go through some examples.</p>
<p><a href="https://leetcode.com/problems/house-robber/">House Robber</a> is an excellent example of a dynamic programming problem.
<a href="https://leetcode.com/problems/longest-increasing-subsequence/">Longest Increasing Subsequence</a> is another example of a classic dynamic programming problem. In this problem, we need to determine the length of the longest (first characteristic) subsequence that is strictly increasing. For example, if we had the input nums = [1, 2, 6, 3, 5]nums = [1, 2, 6, 3, 5], the answer would be 4, from the subsequence [1, 2, 3, 5][1, 2, 3, 5]. Again, the important decision comes when we arrive at the 6 - do we take it or not take it? If we decide to take it, then we get to increase our current length by 1, but it affects the future - we can no longer take the 3 or 5. Of course, with such a small example, it&rsquo;s easy to see why we shouldn&rsquo;t take it - but how are we supposed to design an algorithm that can always make the correct decision with huge inputs? Imagine if nums contained 10,00010,000 numbers instead.</p>
<h3 id="framework-for-dp-problems">Framework for DP problems<a hidden class="anchor" aria-hidden="true" href="#framework-for-dp-problems">#</a></h3>
<p><a href="https://leetcode.com/explore/learn/card/dynamic-programming/631/strategy-for-solving-dp-problems/4096/">LeetCode - Link for this section</a><br>
Before looking at the 3 things that make DP framework, understand what state &amp; state variables are.
<strong>State</strong>: a <strong>state</strong> is a set of variables that can sufficiently describe a scenario. These variables are called <strong>state variables</strong>, and we only care about relevant ones. tldr; all state variables together is the state.</p>
<blockquote>
<ul>
<li>In climbing stairs problem: To describe every scenario in Climbing Stairs, there is only 1 relevant state variable, the current step we are on. We can denote this with an integer ii. If i = 6i = 6, that means that we are describing the state of being on the 6th step. Every unique value of ii represents a unique <strong>state</strong>.</li>
<li>In robbing houses problem: the amount of money in current house is a state variable.</li>
<li>In coin change problem: the denomination is a state variable</li>
</ul>
</blockquote>
<p>Mind map image: imagine that the framework is the tree/graph we are drawing, and now for the nodes we have to choose the state variables of the problem. because of the tree represents all the possible solutions for the problem, and the the state variables are those that we use to traverse in the tree to calculate the value for that path.</p>
<p><strong>FRAMEWORK:</strong></p>
<ol>
<li><strong>A function or data structure that will compute/contain the answer to the problem for every given state</strong>.<br>
Data Structure is straightforward, say we have a dictionary for all the fibonacci numbers {num : fib(num) }<br>
Function: instead of a Data Structure if we have a function that we can call and that returns the value for us.</li>
<li><strong>A recurrence relation to transition between states.</strong></li>
<li><strong>Base cases, so that our recurrence relation doesn&rsquo;t go on infinitely.</strong></li>
</ol>
<h3 id="problem-1-multistage-graph-ythttpswwwyoutubecomwatchv9ie9mj4m8jklistpldn4rrl48xkpzkf03iyfl-o29szjtrs_oindex47">Problem 1: MultiStage Graph <a href="https://www.youtube.com/watch?v=9iE9Mj4m8jk&amp;list=PLDN4rrl48XKpZkf03iYFl-O29szjTrs_O&amp;index=47">YT</a><a hidden class="anchor" aria-hidden="true" href="#problem-1-multistage-graph-ythttpswwwyoutubecomwatchv9ie9mj4m8jklistpldn4rrl48xkpzkf03iyfl-o29szjtrs_oindex47">#</a></h3>
<p>Understanding the problem:
It is a Directed weighted graph. All vertices are divided into stages. First and last stage will only have 1 node, start node and target node. Nodes connect only to the next stage.
Goal is to find the least cost path from start to target. MultiStage Graph&rsquo;s are used for solving resource allocation problems.</p>
<ol>
<li>
<p>Find the minimum cost of each vertex. when we start from 1, we have to already know the minimum cost path for 2,3,4,5 and these nodes depend on min. costs of nodes at V3 and so on. So we begin from last, (Bottom-Up approach, iteratively) because the node 12 is the end and the min. cost of 12 is 0. and from here we trace back.
<img loading="lazy" src="/images/post_images/13/1.jpg" alt="MultiStage Graph"  />

<img loading="lazy" src="/images/post_images/13/2.jpg" alt="MultiStage Graph"  />
</p>
</li>
<li>
<p>Now using forward approach.</p>
</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer><br>
<script src="https://giscus.app/client.js" data-repo="shivajreddy/shivareddydev-comments" data-repo-id="R_kgDOJqO6vw"
  data-category="[ENTER CATEGORY NAME HERE]" data-category-id="[ENTER CATEGORY ID HERE]" data-mapping="pathname"
  data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom"
  data-theme="preferred_color_scheme" data-lang="en" crossorigin="anonymous" async>
  </script>
</article>
    </main>
    
<footer class="footer">
    <nav class="nav">
        <ul id="menu">
            <li>
                <a href="https://shivareddy.dev/" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://shivareddy.dev/resume" title="Resume">
                    <span>Resume</span>
                </a>
            </li>
            <li>
                <a href="https://linktr.ee/shiva.reddy" title="LinkTree"target="_blank" >
                    <span>LinkTree</span>
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://shivareddy.dev/archive" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
        </ul>
    </nav>
    
    
    
    
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script></body>

</html>
